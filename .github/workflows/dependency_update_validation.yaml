name: Dependency Update Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
    paths:
      - 'requirements.txt'
      - 'pyproject.toml'
      - 'lib/charms/**'
      - '**/rockcraft.yaml'
      - '.github/workflows/*.yaml'

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  check-dependency-update:
    name: Validate Dependency Update
    runs-on: ubuntu-latest
    # Run only for Renovate PRs or when labeled
    if: |
      github.event.pull_request.user.login == 'renovate[bot]' ||
      contains(github.event.pull_request.labels.*.name, 'agent:dependency-updater') ||
      contains(github.event.pull_request.labels.*.name, 'renovate') ||
      contains(github.event.pull_request.labels.*.name, 'dependencies')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pip-audit safety packaging
      
      - name: Detect dependency changes
        id: detect-changes
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          
          # Get changed files
          gh pr view $PR_NUMBER --json files --jq '.files[].path' > changed_files.txt
          
          # Detect dependency files
          CHANGED_DEPS=""
          while IFS= read -r file; do
            if [[ "$file" == "requirements.txt" ]] || \
               [[ "$file" == "pyproject.toml" ]] || \
               [[ "$file" == *"rockcraft.yaml" ]] || \
               [[ "$file" == "lib/charms"* ]]; then
              CHANGED_DEPS="${CHANGED_DEPS}${file},"
            fi
          done < changed_files.txt
          
          echo "changed_deps=${CHANGED_DEPS%,}" >> $GITHUB_OUTPUT
          echo "Changed dependency files: $CHANGED_DEPS"
      
      - name: Classify version bump
        id: classify-version
        run: |
          python3 << 'EOF'
          import re
          import sys
          from pathlib import Path
          
          # Read PR title to extract version info
          pr_title = """${{ github.event.pull_request.title }}"""
          
          # Common patterns: "Update package from 1.2.3 to 1.2.4"
          # "Bump package from 1.2.3 to 2.0.0"
          version_pattern = r'(\d+)\.(\d+)\.(\d+).*?(?:to|‚Üí).*?(\d+)\.(\d+)\.(\d+)'
          match = re.search(version_pattern, pr_title)
          
          if match:
              old_major, old_minor, old_patch = int(match.group(1)), int(match.group(2)), int(match.group(3))
              new_major, new_minor, new_patch = int(match.group(4)), int(match.group(5)), int(match.group(6))
              
              if new_major > old_major:
                  bump_type = "major"
                  risk_level = "high"
              elif new_minor > old_minor:
                  bump_type = "minor"
                  risk_level = "medium"
              elif new_patch > old_patch:
                  bump_type = "patch"
                  risk_level = "low"
              else:
                  bump_type = "unknown"
                  risk_level = "medium"
          else:
              bump_type = "unknown"
              risk_level = "medium"
          
          print(f"bump_type={bump_type}")
          print(f"risk_level={risk_level}")
          EOF
          
          RESULT=$(python3 << 'PYEOF'
          import re
          pr_title = """${{ github.event.pull_request.title }}"""
          version_pattern = r'(\d+)\.(\d+)\.(\d+).*?(?:to|‚Üí).*?(\d+)\.(\d+)\.(\d+)'
          match = re.search(version_pattern, pr_title)
          
          if match:
              old_major, old_minor, old_patch = int(match.group(1)), int(match.group(2)), int(match.group(3))
              new_major, new_minor, new_patch = int(match.group(4)), int(match.group(5)), int(match.group(6))
              
              if new_major > old_major:
                  print("bump_type=major")
                  print("risk_level=high")
              elif new_minor > old_minor:
                  print("bump_type=minor")
                  print("risk_level=medium")
              elif new_patch > old_patch:
                  print("bump_type=patch")
                  print("risk_level=low")
              else:
                  print("bump_type=unknown")
                  print("risk_level=medium")
          else:
              print("bump_type=unknown")
              print("risk_level=medium")
          PYEOF
          )
          
          echo "$RESULT" >> $GITHUB_OUTPUT
      
      - name: Run security scan
        id: security-scan
        continue-on-error: true
        run: |
          # Run pip-audit if requirements.txt changed
          if [[ "${{ steps.detect-changes.outputs.changed_deps }}" == *"requirements.txt"* ]]; then
            echo "Running pip-audit on requirements.txt..."
            
            # Run audit
            if pip-audit -r requirements.txt --format json > audit_results.json 2>&1; then
              echo "has_vulnerabilities=false" >> $GITHUB_OUTPUT
              echo "vulnerability_count=0" >> $GITHUB_OUTPUT
            else
              # Parse results
              VULN_COUNT=$(cat audit_results.json 2>/dev/null | python3 -c "import sys, json; data=json.load(sys.stdin); print(len(data.get('dependencies', [])))" 2>/dev/null || echo "0")
              echo "has_vulnerabilities=true" >> $GITHUB_OUTPUT
              echo "vulnerability_count=$VULN_COUNT" >> $GITHUB_OUTPUT
            fi
          else
            echo "has_vulnerabilities=false" >> $GITHUB_OUTPUT
            echo "vulnerability_count=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Wait for CI checks
        id: wait-ci
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const maxWaitTime = 30 * 60 * 1000; // 30 minutes
            const pollInterval = 30 * 1000; // 30 seconds
            let elapsed = 0;
            
            while (elapsed < maxWaitTime) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Check if CI is complete
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const relevantChecks = checks.check_runs.filter(check => 
                check.name !== 'Validate Dependency Update' // Exclude ourselves
              );
              
              if (relevantChecks.length === 0) {
                console.log('No CI checks found yet, continuing...');
                return 'pending';
              }
              
              const allComplete = relevantChecks.every(check => 
                check.status === 'completed'
              );
              
              if (allComplete) {
                const allPassed = relevantChecks.every(check => 
                  check.conclusion === 'success' || check.conclusion === 'skipped'
                );
                
                return allPassed ? 'success' : 'failure';
              }
              
              // Wait before next check
              await new Promise(resolve => setTimeout(resolve, pollInterval));
              elapsed += pollInterval;
            }
            
            return 'timeout';
      
      - name: Generate risk assessment
        id: risk-assessment
        run: |
          python3 << 'EOF'
          import json
          from datetime import datetime
          
          bump_type = "${{ steps.classify-version.outputs.bump_type }}"
          risk_level = "${{ steps.classify-version.outputs.risk_level }}"
          has_vulns = "${{ steps.security-scan.outputs.has_vulnerabilities }}" == "true"
          vuln_count = int("${{ steps.security-scan.outputs.vulnerability_count }}" or "0")
          ci_status = "${{ steps.wait-ci.outputs.result }}"
          
          # Adjust risk level based on factors
          if has_vulns and vuln_count > 0:
              risk_level = "critical" if vuln_count > 2 else "high"
          
          if ci_status == "failure":
              risk_level = "high"
          
          # Determine recommendation
          recommendation = ""
          if risk_level == "low" and ci_status == "success":
              recommendation = "‚úÖ **APPROVED**: Safe to merge after review"
          elif risk_level == "medium" and ci_status == "success":
              recommendation = "‚ö†Ô∏è **MANUAL REVIEW REQUIRED**: Review changes before merging"
          elif risk_level == "high":
              recommendation = "üü† **CAUTION**: High risk update, detailed review needed"
          elif risk_level == "critical":
              recommendation = "üö® **BLOCKED**: Critical issues found, do not merge"
          else:
              recommendation = "‚ÑπÔ∏è **PENDING**: Waiting for more information"
          
          # Risk emoji
          risk_emoji = {
              "low": "üü¢",
              "medium": "üü°",
              "high": "üü†",
              "critical": "üî¥"
          }
          
          assessment = {
              "bump_type": bump_type,
              "risk_level": risk_level,
              "risk_emoji": risk_emoji.get(risk_level, "‚ö™"),
              "has_vulnerabilities": has_vulns,
              "vulnerability_count": vuln_count,
              "ci_status": ci_status,
              "recommendation": recommendation
          }
          
          with open('risk_assessment.json', 'w') as f:
              json.dump(assessment, f, indent=2)
          
          print(f"Risk assessment: {risk_level} ({bump_type} version bump)")
          EOF
      
      - name: Post assessment comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read risk assessment
            const assessment = JSON.parse(fs.readFileSync('risk_assessment.json', 'utf8'));
            
            const prNumber = context.issue.number;
            const prTitle = context.payload.pull_request.title;
            const prAuthor = context.payload.pull_request.user.login;
            
            // Build comment
            let comment = `## ü§ñ Dependency Update Assessment\n\n`;
            comment += `**Update Type**: ${assessment.bump_type.charAt(0).toUpperCase() + assessment.bump_type.slice(1)}\n`;
            comment += `**Risk Level**: ${assessment.risk_emoji} ${assessment.risk_level.charAt(0).toUpperCase() + assessment.risk_level.slice(1)}\n\n`;
            
            comment += `### Security Scan Results\n`;
            if (assessment.has_vulnerabilities) {
              comment += `‚ö†Ô∏è ${assessment.vulnerability_count} potential vulnerabilit${assessment.vulnerability_count > 1 ? 'ies' : 'y'} found\n\n`;
              comment += `**Action**: Review security scan results before merging\n\n`;
            } else {
              comment += `‚úÖ No known vulnerabilities detected\n\n`;
            }
            
            comment += `### CI Status\n`;
            if (assessment.ci_status === 'success') {
              comment += `‚úÖ All checks passed\n`;
            } else if (assessment.ci_status === 'failure') {
              comment += `‚ùå Some checks failed - review required\n`;
            } else if (assessment.ci_status === 'pending') {
              comment += `‚è≥ Checks still running\n`;
            } else {
              comment += `‚è±Ô∏è Checks timed out - manual verification needed\n`;
            }
            comment += `\n`;
            
            comment += `### Recommendation\n`;
            comment += `${assessment.recommendation}\n\n`;
            
            // Add rollback instructions
            comment += `### Rollback Plan\n`;
            comment += `If issues occur after merge, rollback with:\n`;
            comment += `\`\`\`bash\n`;
            comment += `# Revert the merge commit\n`;
            comment += `git revert <commit-hash>\n`;
            comment += `# Or manually restore previous versions\n`;
            comment += `\`\`\`\n\n`;
            
            comment += `---\n`;
            comment += `*Generated by Dependency Update Agent v1.0.0*\n`;
            comment += `*For questions, see \`.github/agents/dependency-update-agent.md\`*\n`;
            
            // Find existing comment to update or create new
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && 
              c.body.includes('Dependency Update Assessment')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              });
            }
            
            // Set appropriate labels
            const labelsToAdd = [];
            if (assessment.risk_level === 'low') {
              labelsToAdd.push('safe-to-merge');
            } else if (assessment.risk_level === 'high' || assessment.risk_level === 'critical') {
              labelsToAdd.push('needs-review');
            }
            
            if (labelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: labelsToAdd
                });
              } catch (e) {
                console.log('Could not add labels (may not exist):', e.message);
              }
            }
            
            // Fail the check if critical risk
            if (assessment.risk_level === 'critical') {
              core.setFailed('Critical risk level detected - manual review required');
            }
